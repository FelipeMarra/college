Construa e posicione regras semânticas na gramática abaixo para realizar a verificação de
compatibilidade de tipos nas expressões da linguagem e nas atribuições. Considere que o
tipo do identificador já está armazenado na entrada da tabela de símbolos dele. Considere
que um identificador pode ter os seguintes tipos: char, short, int e float. Caso as expressões
envolvam o tipo char com int ou float, o compilador deve exibir uma mensagem de erro
informando a incompatibilidade. O mesmo é verdadeiro para expressões que tenham short
com int ou float como operandos. Expressões envolvem apenas int e float são válidas. As
compatibilidades descritas anteriormente também se aplicam às atribuições.
Dica: Ao pensar nas regras semânticas, lembre-se de definir um ou mais atributos que serão
utlizados nas regras semânticas. Não esqueça de posicionar todas as regras na gramática.
Assign -> id = E ; AssignList
AssignList -> id = E ; AssignList | ε
E -> T E'
E'-> + T E' | - T E' | ε
T -> F T'
T' -> * F T' | / F T' | ε
F -> ( E )
F -> integer_const
F -> float_const
F -> id
Terminais = {+,-,*,/,(,),integer_const,float_const,id,=,;,ε}
integer_const representa uma constante numérica inteira
float_const representa uma constante numérica de ponto flutuante

Assign -> id = E ; AssignList
AssignList -> id = E ; AssignList | ε
E -> T [R9] E'
E'-> + T  [R7] E' | - T [R7] E' | ε
T -> F [R8] T'
T' -> * F [R6] T' | / F  [R6] T' | ε
F -> ( E [R5])
F -> [R4] integer_const
F -> [R3] float_const
F -> [R1, R2] id

R1: bool e = Tab_simbolos.consulta(id.lexema);
R2: F.tipo = Tab_simbolos[id.lexema].tipo;
R3: F.tipo = Inteiro;
R4: F.tipo = PontoFlutuante;
R5: F.tipo = E.tipo;
R6: bool r = Verifica_Compat(T'.tipo, F.tipo)
R7: bool r = Verifica_Compat(E'.tipo, T.tipo)
R8: T'.tipo = F.tipo
R9: E'.tipo = T.tipo